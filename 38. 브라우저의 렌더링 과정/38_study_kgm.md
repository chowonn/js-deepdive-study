# 📗챕터 정리
## 개요

자바스크립트는 다른 프로그래밍 언어와 달리 웹 브라우저에서 HTML, CSS와 함께 실행된다.

때문에 자바스크립트 개발자는 웹의 성능과 효율적인 프로그래밍을 위해 브라우저 환경을 고려해야 한다.

브라우저는 다음 과정을 거쳐 렌더링을 수행한다.

1. HTML, CSS, JavaScript, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답 받는다.
2. 브라우저의 렌더링 엔진은 서버에서 받은 HTML, CSS를 파싱해 DOM과 CSSOM을 생성하고, 이를 결합하여 렌더 트리를 생성한다.
3. 브라우저의 자바스크립트 엔진은 서버에서 받은 자바스크립트를 파싱하여 추상적 구문 트리(AST, Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다.
    
    이때, 자바스크립트는 DOM API를 통해 DOM, CSSOM을 변경할 수 있다.
    
    변경된 DOM, CSSOM은 다시 렌더 트리로 결합된다.
    
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치/크기)를 계산하고 브라우저 화면에 요소를 페인팅한다.

---

## 요청과 응답

브라우저의 핵심 기능은 필요한 리소스를 서버에 요청하고, 서버에서 받은 리소스를 브라우저에 시각적으로 렌더링 하는 것이다.

렌더링에 필요한 리소스는 서버에 존재하기 때문에 서버에 리소스를 요청하고, 서버가 응답한 리소르를 파싱하여 렌더링하게 된다.

브라우저 주소창에 URL을 입력하면 URL의 도메인 네임이 DNS를 통해 IP 주소로 변환되어 이 주소를 갖는 서버에 요청을 전송하는 것이다. 

요청과 응답은 개발자 도구의 Network 패널에서 확인할 수 있다.

이미 응답 받은 리소스는 표시되지 않기 때문에 패널에서 리소스를 확인하고 싶다면 페이지를 새로고침 해야 한다.

기본적으로 브라우저가 요청하는 리소스는 HTML 파일이다.

HTML 리소스를 파싱하는 도중에 외부 리소스를 로드하는 태그를 만나면 파싱을 일시중지하고 해당 리소스 파일을 서버에 요청한다.

(CSS 파일을 로드하는 `<link>`, 자바스크립트를 로드하는 `<script>`, 이미지를 로드하는 `<img>`)

---

## HTTP (`HTTP/1.1`, `HTTP/2`)

HTTP란 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)이다.

1991년 최초로 문서화되어 1996년 `HTTP/1.0`, 1999년 `HTTP/1.1`, 2015년 `HTTP/2`가 발표되었다.

`HTTP/1.1`과 `HTTP/2`의 차이를 간략하게 살펴보자.

### 1️⃣ `HTTP/1.1`

기본적으로 한 번에 하나의 요청과 응답만 처리한다.

즉, 여러 개의 요청을 한 번에 전송할 수 없으며 응답 역시 한 개만 받을 수 있다.

HTML 문서 내에 포함된 여러 개의 리소스 요청을 해야 할 때는 `link`, `img`, `script` 태그에 의한 리소스 요청을 개별적으로 전송하고 개별적으로 응답 받는다.

리소스 요청을 동시에 전송할 수 없는 구조이기에 리소스가 많아질 수록 응답 시간이 증가한다.

### 2️⃣ `HTTP/2`

여러 개의 리소스를 동시에 요청할 수 있어 `HTTP/1.1`보다 약 50% 정도 빠르게 응답한다.

---

## 브라우저의 렌더링 과정

파싱이란 프로그래밍 언어로 작성된 리소스를 해석하고 실행하기 위해 리소스의 문자열을 토큰으로 분해하고, 토큰에 문법적 의미와 구조를 반영하여 트리 자료구조인 **파스 트리**를 생성하는 과정을 의미한다.

일반적으로 파싱이 완료된 후에 파스 트리를 기반으로 바이트 코드를 생성하고 실행한다.

브라우저의 렌더링 엔진이 HTML 문서를 파싱할 때 브라우저가 이해할 수 있는 자료구조인 DOM을 생성한다.

HTML을 한 줄씩 순차적으로 파싱해가는데, 외부 리소스 태그를 만나면 파싱을 멈추고 리소스를 서버에 요청한다.

CSS 또한 HTML과 동일한 파싱 과정을 거치며 CSSOM을 생성하고, 작업이 완료되면 DOM의 생성을 재개한다.

HTML 문서를 파싱한 결과물인 DOM(CSSOM)이 완성되면 DOM(CSSOM)을 렌더 트리에 결합한다.

**렌더 트리**는 렌더링을 위한 트리 구조이기 때문에 화면에 렌더링되지 않는 요소인 `<meta>`, `<script>` 등의 노드와 CSS에 의해 비표시되는 노드(*ex*. `display: none;`)는 포함하지 않는다.

완성된 렌더 트리는 각 HTML 요소의 레이아웃(위치/크기)를 계산하는데 사용된다.

위 렌더링 과정은 반복적으로 실행될 수 있다. (**리렌더링**)

- 자바스크립트에 의한 노드 추가 및 삭제
- 브라우저 창의 뷰포트 변경
- 요소 레이아웃(위치/크기) 변경을 발생시키는 스타일 변경

이러한 동작은 비용이 많이 들고 성능에 악영향을 주기 때문에 빈번하게 발생하지 않도록 주의해야 한다.

HTML 문서를 파싱한 결과물로 생성된 DOM은 HTML 문서의 구조, 정보를 담고 있다.

그리고 내부에 담긴 요소, 스타일 정보를 변경할 수 있는 인터페이스인 **DOM API**를 제공한다.

자바스크립트 코드에서 DOM API를 사용하여 의도적으로 DOM과 CSSOM을 변경할 수 있다.

변경된 DOM, CSSOM은 다시 렌더 트리로 결합되고, 변경된 렌더 트리를 기반으로 화면에 리렌더링된다.

---

## 자바스크립트 파싱과 실행

렌더링 엔진이 파싱 과정에서 자바스크립트를 로드하는 `script` 태그를 만나면 자바스크립트 엔진에 제어권을 넘긴다.

이후 자바스크립트 파싱과 실행은 자바스크립트 엔진이 처리한다.

자바스크립트 엔진은 자바스크립트 코드를 파싱하며 추상적 구문 트리(AST, Abstract Syntax Tree)를 생성한다.

그리고 추상적 구문 트리(AST)를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트 코드를 생성하여 실행한다.

자바스크립트 파싱과 실행이 완료되면 다시 렌더링 엔진으로 제어권을 넘겨 HTML 파싱과 DOM 생성을 재개한다.

❗ `<script>` 태그의 위치에 따라 HTML 파싱이 블로킹되어 DOM 생성이 지연될 수 있다.

때문에 `<script>` 태그의 위치는 중요한 의미를 갖는다.

자바스크립트에서 DOM API를 사용하기 위해서는 DOM과 CSSOM이 생성되어 있어야 한다.

자바스크립트를 호출하는 `<script>` 태그가 `<body>` 태그의 상단에 위치하여 DOM이 완성되기 전에 DOM을 조작하게 되면 에러가 발생할 수 있다.

위 같은 문제를 방지할 수 있는 방법이 몇 가지 존재한다.

먼저, `<script>` 태그를 `<body>` 태그의 최하단에 사용하는 것이다.

자바스크립트 코드가 HTML 파싱 마지막에 호출되면서 DOM을 조작하는데 문제가 발생하지 않는다.

두번째 방법으로는 `async` / `defer` 속성을 사용하는 것이다.

```html
<script src="index.js" async></script>
```

두 속성은 자바스크립트 파일을 로드할 때 사용할 수 있으며, 파일의 로드가 비동기적으로 동시에 진행된다.

`async` 속성은 리소스의 로드가 완료된 직후에 자바스크립트 파싱과 실행을 수행하며 HTML 파싱은 중단된다.

`defer` 속성은 HTML 파싱이 완료되는 시점에 자바스크립트 파싱 및 실행을 수행한다.

즉, DOM 생성이 완료된 이후 실행되어야 할 자바스크립트 코드를 로드할 때 사용된다.

<br/>

## 🤔궁금한 점

## 📌중요한 점
